1 704. Binary Search(Easy)
Problem Link:
https://leetcode.com/problems/binary-search/

Solution:
To solve the problem, you need to know how to use binary search.
(1)left inclusion right inclusion
pseudocode:
left = 0;
right = nums.length -1;
while(right <= left){
middle = (left + right) /2; // middle = left +( (right - left) /2)
if(nums[middle] > target) {
right = middle -1;
} else if(nums[middle] < target) {
left = middle + 1;
} else {
return middle;
}
}
return -1;

(2)left inclusion right exclusion
pseudocode:
left = 0;
right = nums.length;
while(right < left){
middle = (left + right) /2;
if(nums[middle] > target) {
right = middle ;
} else if(nums[middle] < target) {
left = middle + 1;
} else {
return middle;
}
}
return -1;

2 27. Remove Element(Easy)
Problem Link:
https://leetcode.com/problems/remove-element/

Solution:
We have two solutions to solve this problem;
(1) Violent Solution
pseudocode:
length = nums.length;
for(int i = 0; i < length; i ++){
if(nums[i] == val){
for(int j = i +1; j < length; j ++){
nums[j-1] = nums[j];
}
i --;
length --;
}
return length;
(2) Double Points
Defined two points: fast point and slow point, fast point finds an element different from val,
slow point records the new array which is different from val.
pseudocode:
slowPoint = 0;
for(int fastPoint = 0; fastPoint < nums.length; fastPoint ++){
if(nums[fastPoint] != val){
nums[slowPoint++] = nums[fastPoint];
}
}
return slowPoint;
1 704. Binary Search(Easy)
Time complexity： O(logN)
Space complexity: O(1)

2 27. Remove Element(Easy)
(1) Violent Solution
Time complexity： O(N^2)
Space complexity: O(1)
(2) Double Points
Time complexity： O(N)
Space complexity: O(1)
